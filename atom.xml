<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学&amp;变</title>
  
  <subtitle>持续学习且愿意改变的人才有未来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://allanming.github.io/"/>
  <updated>2019-03-20T10:56:43.766Z</updated>
  <id>https://allanming.github.io/</id>
  
  <author>
    <name>Allan Ming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Servlet学习</title>
    <link href="https://allanming.github.io/2019/03/08/Servlet%E5%AD%A6%E4%B9%A0/"/>
    <id>https://allanming.github.io/2019/03/08/Servlet学习/</id>
    <published>2019-03-08T09:13:33.000Z</published>
    <updated>2019-03-20T10:56:43.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="servlet是什么"><a class="post-anchor" href="#servlet是什么"></a>Servlet是什么</h2><blockquote><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p><p>Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p><p>最早支持Servlet标准的是JavaSoft的Java Web Server。此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。<br>以上摘自维基百科</p></blockquote><p>Java Applet是Java和浏览器之间的一套图形界面交互接口标准，那么Servlet是浏览端（不一定是浏览器）和Java服务器之间的一套数据交互接口标准。Java应用如果动态的更改、展示数据则必须通过和服务端数据交互，而交互的方式和过程就需求通过Servlet接口来实现。</p><a id="more"></a><h3 id="和cgi程序的区别"><a class="post-anchor" href="#和cgi程序的区别"></a>和CGI程序的区别</h3><blockquote><p><strong>通用网关接口</strong>（Common Gateway Interface/CGI）是一种重要的互联网技术，可以让一个客户端，从网页浏览器向服务器上的程序请求数据。CGI描述了服务器和请求处理程序之间传输数据的一种标准。<br>以上摘自维基百科</p></blockquote><p>从功能的角度看，CGI和Servlet的功能一样，都是客户端和服务器数据交互的一个标准。两者的不同在于实现方式的不同和运行模型的不同。</p><ol><li>两种协议标准，CGI程序可以用多种语言实现，Servlet则只用于Java语言；</li><li>CGI程序与Web Server交互，将数据返回给客户端。Servlet运行于Servlet Container，通过容器返回数据给客户端。也可以由Web Server转发；</li><li>CGI程序在收到客户端请求后会创建进程进行数据处理，如果进程间需要通信则更复杂，进程的创建、销毁、交互系统开销大。Servlet Container在收到请求后，只创建一个进程，多个请求由多个线程做数据处理，系统开销少；</li><li>可移植性，CGI只能运行在实现它的语言运行环境中，只要有JVM环境就可以运行Servlet程序；</li></ol><h3 id="和jsp的关系"><a class="post-anchor" href="#和jsp的关系"></a>和JSP的关系</h3><p>简单说就是：Servlet在Java中写HTML，JSP在HTML中写Java。Servlet主要用于处理业务逻辑，JSP在HTML中处理简单的逻辑和数据输出。在MVC的思想中，由Servlet负责Controller层业务逻辑处理，JSP负责View层数据展示。</p><h3 id="运行环境"><a class="post-anchor" href="#运行环境"></a>运行环境</h3><p>Servlet运行Java虚拟机上，依赖Servlet Container，由容器创建、传递、销毁Servlet对像。</p><h3 id="版本信息"><a class="post-anchor" href="#版本信息"></a>版本信息</h3><p><img src="http://pns5pwze6.bkt.clouddn.com/WX20190311-155207.png?imageMogr2/auto-orient/interlace/1/blur/1x0/quality/70%7Cwatermark/2/text/aHR0cHM6Ly9hbGxhbm1pbmcuZ2l0aHViLmlv/font/YXJpYWw=/fontsize/300/fill/I0ZGRkZGRg==/dissolve/60/gravity/SouthEast/dx/10/dy/5" alt="WX20190311-155207"></p><h2 id="servlet生命周期"><a class="post-anchor" href="#servlet生命周期"></a>Servlet生命周期</h2><p><img src="http://pns5pwze6.bkt.clouddn.com/2cf5e0fe9925bc31930cf45c55df8db1ca1370a5.jpg?imageMogr2/auto-orient/interlace/1/blur/1x0/quality/70%7Cwatermark/2/text/aHR0cHM6Ly9hbGxhbm1pbmcuZ2l0aHViLmlv/font/YXJpYWw=/fontsize/300/fill/I0ZGRkZGRg==/dissolve/60/gravity/SouthEast/dx/10/dy/5" alt="2cf5e0fe9925bc31930cf45c55df8db1ca1370a5"></p><h3 id="线程模型"><a class="post-anchor" href="#线程模型"></a>线程模型</h3><p>从上图中可以看出，它是一个单进程多线程的模型。容器在启动或第一次收到请求时实例化一次Servlet对象，创建一个进程，之后的请求容器都交由该进程下的线程处理。Java线程之间的通信是通过共享内存的方式实现的。容器可以在实例化Servlet对象时设置线程数量。</p><p>每一个Java线程都对应着一个内核线程，所以线程的创建、调度、上下文切换都需要系统内核的支持，会消耗系统资源。</p><h3 id="线程安全"><a class="post-anchor" href="#线程安全"></a>线程安全</h3><p>由于Java多线程之间的通信是通过共享内存实现的，所以当同时操作一个数据时，就会出现不一致的问题。</p><p>要想让并发程序正确的执行，需要解决原子性，可见性、有序性的问题，常用的保障线程安全的方法有加锁、不共享状态、不可变对象。</p><p><strong>线程和锁</strong>是Java语言的并发模型。</p><h2 id="核心接口-功能"><a class="post-anchor" href="#核心接口-功能"></a>核心接口&amp;功能</h2><h3 id="init"><a class="post-anchor" href="#init"></a>init()</h3><p>生命周期方法，当Servlet被实例化时，调用该方法，并传入一个**<code>ServletConfig</code>**对象对Servlet进行初始化。初始化时需要的参数，可以在部署描述文件web.xml中设置，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span> <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>msg<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>init(ServletConfig config)</code>方法中可以通过<code>config.getInitParameter(&quot;msg&quot;)</code>获取msg。</p><h3 id="service"><a class="post-anchor" href="#service"></a>service()</h3><p>生命周期方法，容器接收到请求时，将请求数据**<code>ServletRequest</code><strong>和</strong><code>ServletRsponse</code><strong>传给</strong><code>service(ServletRequest servletRequest, ServletRsponse servletRsponse)</code>**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>service</code>方法中根据请求类型，使用对应的处理方法处理请求，如：<code>doGet</code>、<code>doPost</code>等。HttpServlet的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">String method = req.getMethod();</span><br><span class="line"><span class="keyword">long</span> lastModified;</span><br><span class="line"><span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line"><span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">long</span> ifModifiedSince;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ifModifiedSince = req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line"><span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">resp.setStatus(<span class="number">304</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line"><span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line"><span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line"><span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line"><span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line"><span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line"><span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line"><span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="destroy"><a class="post-anchor" href="#destroy"></a>destroy()</h3><p>生命周期方法，当应用关闭时，Servlet对象销毁时，会调用该方法。</p><h3 id="监听器servletcontextlistener"><a class="post-anchor" href="#监听器servletcontextlistener"></a>监听器ServletContextListener</h3><p><code>ServletContextListener</code>接口提供了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别在生命周期的初始化和销毁阶段触发事件。</p><h3 id="过滤器filter"><a class="post-anchor" href="#过滤器filter"></a>过滤器Filter</h3><p>Filter接口的生命周期也分为三部分：创建、过滤、销毁，分别对应<code>init(FilterConfig filterConfig)</code>、<code>doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3)</code>、<code>destroy()</code>方法。</p><p>web应用程序启动时，web服务器将创建<code>Filter</code>的实例对象，并调用其<code>init</code>方法，读取<strong>web.xml</strong>配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（<code>Filter</code>对象只会创建一次，<code>init</code>方法也只会执行一次）。开发人员通过<code>init</code>方法的参数，可获得代表当前<code>Filter</code>配置信息的<code>FilterConfig</code>对象。</p><p><code>doFilter</code>方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的<strong>URL</strong>时，Servlet容器将先调用过滤器的<code>doFilter</code>方法。<code>FilterChain</code>用户访问后续过滤器。</p><p>Servlet容器在销毁过滤器实例前调用<code>destroy</code>方法，在该方法中释放Servlet过滤器占用的资源。</p><h3 id="异步处理"><a class="post-anchor" href="#异步处理"></a>异步处理</h3><p>Servlet从3.0版本增加了异步处理，可以将耗时业务逻辑异步处理。实现异步处理的方法如下：</p><ul><li><strong>调用<code>asyncContext.start()</code>方法实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/simpleAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line"></span><br><span class="line">        asyncContext.start(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理耗时操作</span></span><br><span class="line">            <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式先通过<code>request.startAsync()</code>获取<code>AsyncContext</code>对象，再调用<code>asyncContext.start()</code>方法实现异步。处理完毕后需要调用<code>complete()</code>方法告知<strong>Servlet容器</strong>。<code>start()</code>方法会向<strong>Servlet容器</strong>另外申请一个新的线程（可以是从<strong>Servlet容器</strong>中已有的主线程池获取，也可以另外维护一个线程池，不同容器实现可能不一样），然后在这个新的线程中继续处理请求，而原先的线程将被回收到主线程池中。事实上，这种方式对性能的改进不大，因为如果新的线程和初始线程共享同一个线程池的话，相当于闲置下了一个线程，但同时又占用了另一个线程。</p><ul><li><strong>通过手动创建线程的方式来实现异步处理</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext asyncContext = request.startAsync();</span><br><span class="line"></span><br><span class="line">Runnable runnable = () -&gt; &#123;</span><br><span class="line">    <span class="comment">//处理耗时操作</span></span><br><span class="line">    <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    asyncContext.complete();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(runnable).start();</span><br></pre></td></tr></table></figure><p>自己手动创建新线程一般是不被鼓励的，并且此时线程不能重用。因此，一种更好的办法是我们自己维护一个线程池。这个线程池不同于Servlet容器的主线程池，如下图：</p><p><img src="http://pns5pwze6.bkt.clouddn.com/Tomcat%E5%92%8CServlet3%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png?imageMogr2/auto-orient/interlace/1/blur/1x0/quality/70%7Cwatermark/2/text/aHR0cHM6Ly9hbGxhbm1pbmcuZ2l0aHViLmlv/font/YXJpYWw=/fontsize/300/fill/I0ZGRkZGRg==/dissolve/60/gravity/SouthEast/dx/10/dy/5" alt="Tomcat和Servlet3的异步处理流程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    AsyncContext asyncContext = request.startAsync();</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//处理耗时操作</span></span><br><span class="line">        <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        asyncContext.complete();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet 3.0对请求的处理虽然是异步的，但是对InputStream和OutputStream的IO操作却依然是阻塞的，对于数据量大的请求体或者返回体，阻塞IO也将导致不必要的等待。Servlet 3.0允许异步请求处理，但仅限于传统I/O。因此在Servlet 3.1中引入了非阻塞IO，通过在HttpServletRequest和HttpServletResponse中分别添加ReadListener和WriterListener方式，只有在IO数据满足一定条件时（比如数据准备好时），才进行后续的操作。实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext context = request.startAsync();</span><br><span class="line">ServletInputStream input = request.getInputStream();</span><br><span class="line">input.setReadListener(<span class="keyword">new</span> MyReadListener(input, context));</span><br></pre></td></tr></table></figure><p>setXXXListner方法指出采用非阻塞I/O而不是传统I/O。ReadListener可以通过<code>ServletInputStream</code>进行注册，同样地，Writelistener可以通过<code>ServletOutputStream</code>进行注册。新增加的<code>ServletInputStream.isReady</code>方法和<code>ServletInputStream.isFinished</code>方法用于检测非阻塞I/O的读取状态，而<code>ServletOutputStream.canWrite</code>方法用于检测数据是否能够无阻塞地写入。</p><p>MyReadListener的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadListener</span> <span class="keyword">implements</span> <span class="title">ReadListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> (input.isReady()</span><br><span class="line">                &amp;&amp; (len = input.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String data = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(<span class="string">"--&gt; "</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            Logger.getLogger(MyReadListener.class.getName()).log(Level.SEVERE, <span class="keyword">null</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAllDataRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"onAllDataRead"</span>);</span><br><span class="line">        context.complete();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        context.complete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现有三处回调：</p><ul><li>onDataAvailable方法在数据可以无阻塞读取的时候进行调用。</li><li>onAllDataRead方法在当前请求已经完全读取完毕的时候调用。</li><li>onError方法在处理请求出错的时候调用。</li></ul><p>WriteListener有两个回调方法：</p><ul><li>onWritePossible是可以无堵塞写入数据被调用时</li><li>onerror的是如果有错误处理响应时被调用</li></ul><p>最多只有一个WriteListener可以在ServletOutputStream注册。 ServletOut putStream.canWrite是一种新的方法检查数据是否可以不阻塞地被写入。</p><h2 id="部署描述文件"><a class="post-anchor" href="#部署描述文件"></a>部署描述文件</h2><h3 id="web-xml和web-fragment-xml"><a class="post-anchor" href="#web-xml和web-fragment-xml"></a>web.xml和web-fragment.xml</h3><p>在Servlet3.0以前，一个web应用的任何配置都需要在<code>web.xml</code>中配置描述，灵活性差，容易混乱。3.0版本引入了部署描述片段的概念<code>web-fragment.xml</code>，<code>web-fragment.xml</code>和<code>web.xml</code>配置一样，根元素的<code>schemaLocation</code>不同。<code>web-fragment.xml</code>放在jar包中的<strong>META-INF</strong>目录中，这样一个模块的部署、卸载不需要改动<code>web.xml</code>，使web应用可以进行解耦、模块化封装。</p><h3 id="发现和加载顺序"><a class="post-anchor" href="#发现和加载顺序"></a>发现和加载顺序</h3><p>参见Servlet3标准：<a href="https://jinnianshilongnian.iteye.com/blog/1750736" target="_blank" rel="noopener">注解和可插拔性</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;servlet是什么&quot;&gt;&lt;a class=&quot;post-anchor&quot; href=&quot;#servlet是什么&quot;&gt;&lt;/a&gt;Servlet是什么&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。&lt;/p&gt;
&lt;p&gt;Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。&lt;/p&gt;
&lt;p&gt;最早支持Servlet标准的是JavaSoft的Java Web Server。此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。&lt;br&gt;
以上摘自维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java Applet是Java和浏览器之间的一套图形界面交互接口标准，那么Servlet是浏览端（不一定是浏览器）和Java服务器之间的一套数据交互接口标准。Java应用如果动态的更改、展示数据则必须通过和服务端数据交互，而交互的方式和过程就需求通过Servlet接口来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://allanming.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://allanming.github.io/tags/Java/"/>
    
      <category term="Servlet" scheme="https://allanming.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>对偶佳句</title>
    <link href="https://allanming.github.io/2019/03/03/%E5%AF%B9%E5%81%B6%E4%BD%B3%E5%8F%A5/"/>
    <id>https://allanming.github.io/2019/03/03/对偶佳句/</id>
    <published>2019-03-03T07:10:42.000Z</published>
    <updated>2019-03-20T10:58:15.125Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘自《人民日报》</p></blockquote><h2 id="时令佳节"><a class="post-anchor" href="#时令佳节"></a>时令佳节</h2><ol><li>山抹绿，燕剪柳。</li><li>杏花盛，桑叶白。</li><li>梅花尽落，柳眼初开。</li><li>十里荷红，三秋桂香。</li><li>迟日江山绿，春风花草香。</li><li>清霜浸碧波，白露下黄叶。</li><li>海日生残夜，江春入旧年。</li><li>纷纷黄叶坠，对对塞鸿飞。</li><li>秋河曙耿耿，寒渚夜苍苍。</li><li>蝉鸣哀暮夏，莺啭怨残春。</li><li>明月别枝惊鹊，清风半夜鸣蝉。</li><li>沾衣欲湿杏花雨，吹面不寒杨柳风。</li><li>漠漠水田飞白鹭，阴阴夏木啭黄鹂。</li><li>丝飘弱柳平桥晚，雪点香梅小院春。</li><li>遥闻爆竹知更岁，偶见梅花觉已春。</li><li>梨花院落溶溶月，柳絮池塘淡淡风。</li><li>茸铺草色春江曲，雪剪花梢玉砌前。</li><li>满地绿阳飞燕子，一帘晴花卷梅花。</li><li>杏花初落疏疏雨，杨柳轻摇淡淡风。</li><li>缕缕青烟芳草渡，丝丝微雨杏花村。</li></ol><a id="more"></a><h2 id="山水花鸟"><a class="post-anchor" href="#山水花鸟"></a>山水花鸟</h2><ol><li>桃花灼灼，杨柳依依。</li><li>雾失楼台，月迷津渡。</li><li>鱼翻藻鉴，鹭点烟汀。</li><li>百花含蓄，千枝泛绿。</li><li>蝉嗓林愈静，鸟鸣山更幽。</li><li>明月松间照，清泉石上流。</li><li>绿树村边合，青山郭外斜。</li><li>鱼戏新荷动，鸟散余花落。</li><li>疏影横斜水清浅，暗香浮动月黄昏。</li><li>无可奈何花落去，似曾相识燕归来。</li><li>一池芙蓉新出水，千层芳草远浮山。</li><li>池上碧苔三四点，叶底黄鹂一两声。</li><li>自在飞花轻似梦，无边丝雨细如愁。</li><li>夜凉吹笛千山月，路暗迷人百种花。</li><li>桃花细逐杨花落，黄鸟时兼白鸟飞。</li><li>乱花渐欲迷人眼，浅草才能没马蹄。</li><li>小院回廊春寂寂，浴凫飞鹭晚悠悠。</li><li>高树夕阳连远巷，小桥流水接平沙。</li><li>风吹云动星不动，水推船移岸不移。</li><li>彩霞照万里如银，素魄映千山似水。</li></ol><h2 id="人生哲理"><a class="post-anchor" href="#人生哲理"></a>人生哲理</h2><ol><li>满招损，谦受益。</li><li>志不求易，事不避难。</li><li>近朱者赤，近墨者黑。</li><li>路遥知马力，日久见人心。</li><li>时危见臣节，世乱识忠良。</li><li>傍水知鱼性，近山识鸟音。</li><li>静坐常思已过，闲谈莫论人非。</li><li>非淡泊无以明志，非宁静无以致远。</li><li>世事洞明皆学问，人性练达即文章。</li><li>水能性淡为吾友，竹解心虚是我师。</li><li>世事静观知曲折，人心甘苦见交情。</li><li>年年岁岁花相似，岁岁年年人不同。</li><li>有志始知蓬莱近，无为总觉咫尺远。</li><li>黑发不知勤学早，白首方悔读书迟。</li><li>世上本无常照月，天边还有再来春。</li><li>风定始知蝉在树，灯残方见月临窗。</li><li>静可观人虚能修已，贤当迷古智足察今。</li><li>登高而尽四野所有，著书以成一家之言。</li><li>千里长堤溃于蚁穴，万丈高台始于一石。</li><li>世事如棋一着争来千古业，柔情似水几时流尽六朝春。</li></ol><h2 id="腹有诗书"><a class="post-anchor" href="#腹有诗书"></a>腹有诗书</h2><ol><li>持之有故，言之成理。</li><li>苦读有恒，好学无时。</li><li>挥毫列锦绣，落纸如云烟。</li><li>笔落惊风雨，诗成泣鬼神。</li><li>雪夜书千卷，花时酒一瓢。</li><li>文心清若水，诗胆大如天。</li><li>惟止乃能动，因昧而为明。</li><li>高论明秋水，新诗动洛川。</li><li>山川佳色澄悬镜，松竹清阴静读书。</li><li>虎尾春冰真学问，马蹄秋水妙文章。</li><li>无尽波涛归学海，长春花木在词林。</li><li>友如作画须求淡，山似论文不喜平。</li><li>观书到老眼如月，得名惊人胸有珠。</li><li>学海无涯勤可渡，书山万仞志能攀。</li><li>灯火夜深书有味，墨花晨湛字生光。</li><li>一帘花影云拖地，半夜书声月在天。</li><li>书到用时方恨少，事非经过不知难。</li><li>窗外日光弹指过，席前花影坐间移。</li><li>春亦多情鸟向枝头催逸兴，人其得意梅从窗外放诗怀。</li><li>长吟玉海诗兴动江山皆入句，大开春酒会醉余天地总为家。</li></ol><h2 id="言志抒怀"><a class="post-anchor" href="#言志抒怀"></a>言志抒怀</h2><ol><li>芳草有情，夕阳无语。</li><li>海阔凭鱼跃，天高任鸟飞。</li><li>生当作人杰，死亦为鬼雄。</li><li>江山如有待，花柳自无私。</li><li>直如朱丝绳，清似玉壶冰。</li><li>皓月无幽意，清风有泪情。</li><li>同淤泥而不染，濯清涟而不妖。</li><li>朝饮木兰之坠露，夕餐秋菊之落英。</li><li>先天下之忧而忧，后天下之乐而乐。</li><li>十里水光心地朗，一林花色性天空。</li><li>抽刀断水水更流，举杯消愁愁更愁。</li><li>万花敢向雪中出，一树独先天下春。</li><li>狂澜欲倒同心挽，旭日方升旦气扬。</li><li>观水有情不言自喻，游山寄兴未尽所怀。</li><li>石可破而不可夺坚，丹可磨而不可夺赤。</li><li>噪晚齐蝉岁岁秋来泣恨，啼宵蜀鸟年年春去伤魂。</li><li>关山难越谁悲失路之人，萍水相逢尽是他乡之客。</li><li>吟成赏月之诗只愁月堕，斟满送春之酒惟憾春归。</li><li>竹径萧条平生壮志三更梦，云山缥缈万里秋风一雁哀。</li><li>千尺水帘今古无人能手卷，一轮月镜乾坤何匠用功磨。</li></ol><h2 id="风流人物"><a class="post-anchor" href="#风流人物"></a>风流人物</h2><ol><li>物华天宝，人杰地灵。</li><li>手挥五弦，目送归鸿。</li><li>星斗其文，赤子其人。</li><li>棋逢对手，将遇良材。</li><li>落花人独立，微雨燕双飞。</li><li>仰首接飞猱，俯身散马蹄。</li><li>掬水月在手，弄花香满衣。</li><li>双眸剪秋水，十指剥春葱。</li><li>功盖三分国，名成八阵图。</li><li>不才明主弃，多病故人疏。</li><li>红颜弃轩冕，白首卧松云。</li><li>浮云游子意，落日故人情。</li><li>斯人千古少，此同世间无。</li><li>长江人钓月，旷野火烧风。</li><li>志士惜日短，愁人嫌夜长。</li><li>室有惠崇山水，人怀与可风流。</li><li>三寸巧舌力挽狂澜纾国难，一番善言情荡衷肠罢干戈。</li><li>诗史数千言，秋天一鹄先生骨；草堂三五里，春水群鸥野老心。</li></ol><h2 id="君子之交"><a class="post-anchor" href="#君子之交"></a>君子之交</h2><ol><li>驿寄梅花，鱼传尺素。</li><li>海内存知己，天涯若比邻。</li><li>绿蚁新醅酒，红泥小火炉。</li><li>一尊对明月，三径来故人。</li><li>高堂思琴瑟，别路绕山川。</li><li>胜游朝挽袂，妙语夜连床。</li><li>蓝桥春雪君归日，秦岭秋风我去时。</li><li>常因流水思念日，每托清风怀故人。</li><li>万卷书容闲客览，一樽酒待故人倾。</li><li>喜有两眼明多交友，恨无十年暇读奇书。</li><li>说一声去也送别河头叹梦里长驱过桥便入天涯路，盼今日归哉迎来道左喜故人握手见面还疑梦里身。</li></ol><h2 id="风月情浓"><a class="post-anchor" href="#风月情浓"></a>风月情浓</h2><ol><li>东风恶，欢情薄。</li><li>落花有意，流水无情。</li><li>月上柳梢头，人约黄昏后。</li><li>迢迢牵牛星，皎皎河汉女。</li><li>春蚕到死丝方尽，蜡炬成灰泪始干。</li><li>身无彩凤双飞翼，心有灵犀一点通。</li><li>山月不知心里事，水风空落眼前花。</li><li>曾经沧海难为水，除却巫山不是云。</li><li>相见时红雨纷纷点绿苔，别离后黄叶萧萧凝暮霭。</li><li>秋离佳人目送楼头千里雁，早行远客梦惊枕上五更鸣。</li><li>菱花镜孤哉惨听秋风吹落叶，锦机声寂矣愁看夜月照空帏。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘自《人民日报》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;时令佳节&quot;&gt;&lt;a class=&quot;post-anchor&quot; href=&quot;#时令佳节&quot;&gt;&lt;/a&gt;时令佳节&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;山抹绿，燕剪柳。&lt;/li&gt;
&lt;li&gt;杏花盛，桑叶白。&lt;/li&gt;
&lt;li&gt;梅花尽落，柳眼初开。&lt;/li&gt;
&lt;li&gt;十里荷红，三秋桂香。&lt;/li&gt;
&lt;li&gt;迟日江山绿，春风花草香。&lt;/li&gt;
&lt;li&gt;清霜浸碧波，白露下黄叶。&lt;/li&gt;
&lt;li&gt;海日生残夜，江春入旧年。&lt;/li&gt;
&lt;li&gt;纷纷黄叶坠，对对塞鸿飞。&lt;/li&gt;
&lt;li&gt;秋河曙耿耿，寒渚夜苍苍。&lt;/li&gt;
&lt;li&gt;蝉鸣哀暮夏，莺啭怨残春。&lt;/li&gt;
&lt;li&gt;明月别枝惊鹊，清风半夜鸣蝉。&lt;/li&gt;
&lt;li&gt;沾衣欲湿杏花雨，吹面不寒杨柳风。&lt;/li&gt;
&lt;li&gt;漠漠水田飞白鹭，阴阴夏木啭黄鹂。&lt;/li&gt;
&lt;li&gt;丝飘弱柳平桥晚，雪点香梅小院春。&lt;/li&gt;
&lt;li&gt;遥闻爆竹知更岁，偶见梅花觉已春。&lt;/li&gt;
&lt;li&gt;梨花院落溶溶月，柳絮池塘淡淡风。&lt;/li&gt;
&lt;li&gt;茸铺草色春江曲，雪剪花梢玉砌前。&lt;/li&gt;
&lt;li&gt;满地绿阳飞燕子，一帘晴花卷梅花。&lt;/li&gt;
&lt;li&gt;杏花初落疏疏雨，杨柳轻摇淡淡风。&lt;/li&gt;
&lt;li&gt;缕缕青烟芳草渡，丝丝微雨杏花村。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
